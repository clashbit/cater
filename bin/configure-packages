#!/usr/bin/env node

// Copyright Jon Williams 2017. See LICENSE file.
const fs = require("fs");
const path = require("path");

// Packages that are optionally installed in a example or package directory
const WHITELIST_PACKAGES = ["express"];

//    "babel-core": "^6.26.0",
// "webpack": "^3.10.0"

// Packages versioned together across all of cater
const KEY_DEV_DEPENDENCIES = {
  jest: "^22.0.4"
};

const readPackageFile = function(...args) {
  const packageFile = path.join(...args);
  if (!fs.existsSync(packageFile)) return null;
  const content = fs.readFileSync(packageFile).toString();
  return JSON.parse(content);
};

// Get the version from the top level package.json
const masterPackage = readPackageFile(__dirname, "..", "package.json");
const version = masterPackage.version;

const updatePackageFile = function(...args) {
  const fn = args.pop();
  const packageFile = path.join(...args);
  const package = readPackageFile(...args);
  if (package === null) return null;

  // Get whitelist dependencies
  const deps = Object.assign({}, package.dependencies);
  const devs = Object.assign({}, package.devDependencies);
  const addDeps = WHITELIST_PACKAGES.filter(x => Object.keys(deps).includes(x));
  const addDevs = Object.keys(package.devDependencies || {}).filter(k => k.startsWith("cater-"));

  const updatedPackage = fn(package);

  // Add back in whitelisted dependencies
  addDeps.forEach(name => (updatedPackage.dependencies[name] = deps[name]));
  addDevs.forEach(name => (updatedPackage.devDependencies[name] = devs[name]));

  if (updatedPackage.dependencies) {
    Object.keys(updatedPackage.dependencies)
      .filter(k => k.startsWith("cater-"))
      .forEach(k => {
        updatedPackage.dependencies[k] = `^${version}`;
      });
  }

  // Jest package dependencies
  if (updatedPackage.devDependencies) {
    // Update packages like jest
    Object.keys(KEY_DEV_DEPENDENCIES)
      .filter(k => !!updatedPackage.devDependencies[k])
      .forEach(k => {
        updatedPackage.devDependencies[k] = KEY_DEV_DEPENDENCIES[k];
      });

    // Update cater-* packages to be the same overall version
    Object.keys(updatedPackage.devDependencies)
      .filter(k => k.startsWith("cater-"))
      .forEach(k => {
        updatedPackage.devDependencies[k] = `^${version}`;
      });
  }

  fs.writeFileSync(packageFile, JSON.stringify(updatedPackage, null, 2));
  return updatedPackage;
};

const exampleTemplate = {
  author: "Jon Williams <jon@jonathannen.com> https://jonathannen.com",
  license: "MIT",
  version: version,
  private: true,
  dependencies: {
    cater: `^${version}`
  },
  devDependencies: {
    "cater-build": `^${version}`,
    "cater-jest": `^${version}`,
    "jest": "^22.0.4",
    supertest: "^3.0.0"
  }
};

const packageTemplate = {
  author: "Jon Williams <jon@jonathannen.com> https://jonathannen.com",
  license: "MIT",
  version: masterPackage.version,
  scripts: {
    test: "jest"
  }
};

const scripts = {
  build: "cater build",
  dev: "cater dev",
  start: "cater start",
  test: "jest"
};

// Example Packages
const exampleDirectory = path.join(__dirname, "..", "examples");
fs.readdirSync(exampleDirectory).forEach(directory => {
  const result = updatePackageFile(exampleDirectory, directory, "package.json", pkg => {
    pkg.name = directory;
    pkg = Object.assign(pkg, exampleTemplate);

    Object.keys(scripts).forEach(k => {
      if (!!pkg.scripts[k]) return;
      pkg.scripts[k] = scripts[k];
    });

    return pkg;
  });
});

// Regular Packages
const packageDirectory = path.join(__dirname, "..", "packages");
fs.readdirSync(packageDirectory).forEach(directory => {
  const result = updatePackageFile(packageDirectory, directory, "package.json", pkg => {
    pkg.name = directory;
    return Object.assign(pkg, packageTemplate);
  });
});
